# Abstract
[BerlinMOD](http://dna.fernuni-hagen.de/secondo/BerlinMOD/BerlinMOD.html) is a benchmark for spatio-temporal database management systems. The benchmark generates trips of moving vehicles within Berlin. BerlinMODPlayer is a player for such trips. The Player reads the data generated by BerlinMOD and generates a stream of GPS coordinates therefrom. The stream of GPS coordinates can be used to benchmark stream processing systems.

# Introduction
Stream processing systems are used to process the content of data streams. Such data streams are often generated when moving or changing objects are observed and the observation is recorded progressive. For example, the changing price of
a stock, the speed of an engine or the position of a vehicle. BerlinMOD is a benchmark that generates trips of moving vehicles within Berlin. BerlinMODPlayer is a software that reads the generated trips and creates a stream of GPS coordinates therefrom. That stream is written to a TCP socket. In a real world scenario, such data stream is generated by a fleet of vehicles moving through the streets of a city and sending their GPS coordinates to a central system.

## Basics
A movement beginning at the coordinate _(xstart, ystart)_ and ending at the coordinate _(xend, yend)_ will be called trip in this paper. A trip is composed of smaller movements, called units (as illustrated in Fig. 1). Trips and units 1 are describing a movement, starting at time t0 and ending at time t1. Inside the interval [t0, t1] the trip is called valid. Outside this time interval, the trip is invalid.

![Figure 1](doc/images/trips.png)

Figure 1: The trip on a map from point A to point B is composed of three units (u1, u2, u3).

## BerlinMod
BerlinMOD is a benchmark for spatio-temporal database management systems. This benchmark includes a generator for moving objects and a set of queries to benchmark the performance of a database management system. In this paper, the data generator is used to create the input data (further called the input file) for BerlinMODPlayer. The basic idea of the data generator of BerlinMOD is to define a set of vehicles and to generate trips on the street network of Berlin. Each vehicle has a HomeNode, representing the holder’s residence and a WorkNode, representing the working place of the holder. Additionally, a set of nodes in the Neighborhood around the HomeNode are used. The data generator creates trips from the HomeNode to the WorkNode and trips to the nodes in the neighborhood. For more details about the creation of trips, see [the BerlinMOD homepage](http://dna.fernuni-hagen.de/secondo/BerlinMOD/BerlinMOD.html). The data generator of BerlinMOD consists of a set of quires for the the extensible database management system (http://dna.fernuni-hagen.de/secondo/)[Secondo].

# BerlinMODPlayer
The following subsections will describe the basic concepts of the BerlinMODPlayer. In addition, the architecture of the software will be discussed. BerlinMODPlayer simulates the movement of vehicles. Consequently, the execution of the software will also referred as _simulation_.

## Command line arguments
The software accepts some arguments, to influence the program behavior and the generated data stream. So, the begin time and the end time of the simulation can be settled, the destination host and port can be specified, to name just a few of the arguments.

| Parameter |        Name       |         Description                 |
|-----------|-------------------|-------------------------------------|
| -i        | Input file        | The file name of the input file.    |
| -u        | Output URL        | The format and the transport for the output. |
| -s        | Simulation mode   | The simulation mode that should be used |
| -o        | Output file       | The output file for the statistics   |
| -b        | Begin time offset | Optional: The time when the simulation should begin. If the parameter is omitted, the simulation begins with the first line of the input file. The time has to be specified in the format: `yyyy-mmm-dd hh:mm:ss` |
| -e        | End time offset   | Optional: The time when the simulation should end. If the parameter is omitted, the simulation ends with the last line of the input file. |

__Example__: Run the BerlinMODPlayer and send the GPS updates to localhost port 10 025 (TCP) in CSV format using the adaptive simulation mode. The statistics are written into the file statistics.txt. The file trips.csv contains
the data generated by BerlinMOD.

    ./bmodplayer -i trips.csv -u tcp://localhost/10025 -s adaptive -o statistics.txt

## Statistics
During the program execution, statistical information of the simulation is written to an output file. This file contains a line for every second of the simulation. Every line consists of five fields: (i) the first field contains the number of seconds passed since the simulation has begun. (ii) The second field contains the amount of read lines from the input file. (iii) The third field contains the amount of written lines on the network socket. (iv) The fourth field contains the amount of read tuples in the last second. (v) The last field contains the amount of sent tuples in the last second.

```
#Sec  Read  Write   Diff read   Diff send
0     0     0       0           0
1     65554 55460   65554       55460
2     135112 124987 69558       69527
[...]
### Total execution time (ms): 11004
### Read: 459974
### Send: 459974
```

The format of the file can easily processed with tools like Gnuplot. The last three lines of the file describe the total execution time of the simulation and the total amount of read and written coordinates.

## The GPS coordinate data stream
BerlinMODPlayer generates a stream of GPS coordinates. The output URL determines the output transport and the output format. Currently, two different output formats and transports are supported: (i) the data can be send in the CSV format (Comma-separated values) via a TCP socket or (ii) the data can be send in the JSON format (JavaScript Object Notation) [5] via HTTP requests. Both formats and transports are discussed in the next sections. The next table describes the structure of the supported output URLs.

|       Output URL           | Description        |
|----------------------------|--------------------|
| tcp://myhostname/myport    | Send the output in CSV format via TCP to the host _myhostname_ on port _myport_. |
| http://myhostname/document | Send the output in JSON format via HTTP-Requests to the URL http://myhostname/document. |

### CSV format and TCP output
Every GPS coordinate is represented as a line with five fields: (i) The time stamp when the coordinate is measured, (ii) the object, i.e. the vehicle, who has measured the coordinate, (iii) an id for the trip and (iv) the X and (v) the Y coordinate.

![Figure](doc/images/csv.png)

The generated coordinate stream consists of lines in the format described above, ordered by the time stamp of the lines. For example:

```
28-05-2007 10:00:14,10,1313,13.2967,52.4502
28-05-2007 10:00:15,22,3107,13.2178,52.5086
28-05-2007 10:00:15,112,16315,13.2063,52.5424
28-05-2007 10:00:15,6,751,13.322,52.4626
```

After the last coordinate update is send, the ascii _character end of transmission (EOT)_ will be send, to indicate the end of the data stream. Afterwards, the tcp connection will be closed.

### JSON format and HTTP output
Alternatively, the GPS coordinate stream can send via HTTP PUT-Requests. For that kind of output, the GPS coordinates are converted into the JSON format. One coordinate in JSON format looks like:
```
{
    "Id":"100000000000000",
    "Position":{
        "date":"2015-03-06T23:20:01.000",
        "x":13.141600000000002,
        "y":13.141600000000002
    }
}
```

Each coordinate update is send via a single HTTP request to the URL, indicated by the output URL.

## Process the GPS coordinate stream with SECONDO
Secondo contains an operator called csvimport, to import csv separated data into a relation. This operator can read the data from a file or from a network socket. In this paper, the operator is used to import the generated GPS coordinate stream into Secondo. The Operator requires at least three arguments: (i) The data source, (ii) the amount of lines to skip and (iii) the used comment character. All lines beginning with the comment character will be skipped. The operator reads each line from the data source and parses the content, until the input is processed completely. When the data is read from a file, the end of the input is indicated by reaching the end of the file. When the data is read from a network socket, the end is indicated by the ascii character EOT.

__Example:__ The following query in Secondo will open a TCP socket on port 10025 and read all the received GPS coordinate updates from the TCP socket. Every coordinate update is converted into a tuple and send to the operator count. After the query finishes, the total amount of received tuples is printed to the console.

```
query [ const rel(tuple([Time: string, Moid: int, Tripid: int, X: real, Y: real])) 
   value() ] csvimport [’tcp://10025’, 0, ""] count;
```

## Architecture
The software is developed with an architectural focus on producing high amounts of GPS updates. BerlinModPlayer is written in C++ and uses the POSIX thread library to create multiple threads and utilize the available hardware as good as possible (see Figure 2). The input data is read by a _Producer Thread_ and placed into a vector. In this vector, the data can be reordered or processed otherwise, depending on the simulation mode.

Occasionally, the content of the vector is moved to a fifo. A second thread, the _Consumer Thread_, reads the data from the fifo and writes them to the network socket. The fifo is the compound between the Producer and the Consumer Thread. Both threads are accessing the fifo simultaneously. To prevent race conditions, the access to the fifo needs to be synchronized. Due to the synchronization, only one thread can access the fifo at the same time. If boththreads want to access the fifo one thread will be blocked and has to wait until the other thread has finished the access. To ensure that both threads can perform their work without waiting much time, the above mentioned vector was introduced. With this vector, the Producer Thread can read data into the memory and placing it into the vector without interfering the consumer thread. Most of the time, the Consumer Thread can access the fifo exclusively. Only in the moment, when the data from the vector is moved to the fifo, simultaneous access to the fifo is needed. A third thread, the _Statistics Thread_, is collecting statistical information about the read and written data and writes it to the console and into a file.

![Figure 2](doc/images/architecture.png)

Figure 2: The architecture of the BerlinMODPlayer. The software uses three threads to do tier work: (i) A producer thread, (ii) a consumer thread and (iii) a statistics thread.

## Simulation Modes
BerlinMODPlayer provides currently two different simulation modes: (i) fixed and (ii) adaptive. The simulation mode determines how the trips, generated by BerlinMOD, are handled.
